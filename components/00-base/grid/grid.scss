//
// Grid component.
//

@use 'sass:map';

//
// Max width container class to limit the width of the fluid containers at max width.
//
.container-max-width {
  @include ct-breakpoint(xxl) {
    width: $ct-grid-max-width;
    margin: 0 auto;
  }
}

//
// Offset container class to add offset on small screens.
//
.container-offset-xs {
  @include ct-breakpoint-upto(m) {
    padding-left: map.get($ct-grid-offsets, 'xxs');
    padding-right: map.get($ct-grid-offsets, 'xxs');
    width: auto;
  }
}

// Container class should wrap every row.
.container {
  @include ct-container();

  &--fill-width {
    > .col,
    > [class*='col-'] {
      max-width: 100%;
      flex-grow: 1;
    }
  }
}

.row {
  $root: &;

  @include ct-row($ct-grid-gutters);

  &#{$root}--reverse {
    flex-direction: row-reverse;
  }

  &#{$root}--no-grow {
    > .col,
    > [class*='col-'] {
      flex-grow: initial;
      flex-basis: auto;
    }
  }

  &#{$root}--equal-heights-content {
    > .col,
    > [class*='col-'] {
      > * {
        height: 100%;
      }
    }
  }

  &#{$root}--unequal-heights {
    > .col,
    > [class*='col-'] {
      margin-bottom: auto;
    }
  }
}

ul.row {
  margin-top: 0;
  margin-bottom: 0;
}

.col {
  $root: &;

  // Make columns at the lowest breakpoint to act as a single column per row.
  @include _ct-grid-col($ct-grid-lowest-breakpoint, $ct-grid-columns);

  $next-bp: ct-map-get-next($ct-breakpoints, $ct-grid-lowest-breakpoint, map.get($ct-breakpoints, 'xxs'), key);

  // Spawn columns to fit into as single row for larger breakpoints.
  @include ct-breakpoint($next-bp) {
    @include _ct-grid-col();
  }
}

// Generate column classes.
@each $breakpoint, $value in $ct-breakpoints {
  @if $breakpoint == $ct-grid-lowest-breakpoint {
    @include _ct-col-factory($breakpoint);
  }
  @else {
    @include ct-breakpoint($breakpoint) {
      @include _ct-col-factory($breakpoint);
    }
  }
}

// Utilities for fixed and auto columns.
.col,
[class*='col-'] {
  &.col--reverse {
    display: flex;
    flex-direction: column-reverse;
  }

  &.col--no-grow {
    flex-grow: initial;
    flex-basis: auto;
  }

  &.col--no-gap {
    // Remove the offsets starting from the next breakpoint from the lowest one.
    @include ct-breakpoint(ct-breakpoint-next($ct-grid-lowest-breakpoint, key)) {
      &:not(:first-child) {
        padding-left: 0;
      }

      &:not(:last-child) {
        padding-right: 0;
      }
    }
  }
}

.first {
  order: -1;
}

.last {
  order: 1;
}

.align-start {
  align-self: flex-start;
}

.align-end {
  align-self: flex-end;
}

.align-center {
  align-self: center;
}

.align-baseline {
  align-self: baseline;
}

.align-stretch {
  align-self: stretch;
}

.ct-justify-content-start {
  display: flex;
  justify-content: flex-start;
}

.ct-justify-content-center {
  display: flex;
  justify-content: center;
}

.ct-justify-content-end {
  display: flex;
  justify-content: flex-end;
}

.ct-text-align-left {
  text-align: left;
}

.ct-text-align-center {
  text-align: center;
}

.ct-text-align-right {
  text-align: right;
}

.ct-align-middle {
  display: flex;
  flex-direction: row;
  align-items: center;
  height: 100%;
}
